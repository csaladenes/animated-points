{"version":3,"file":null,"sources":["../src/AnimatedPoints.js"],"sourcesContent":["'use strict';\r\nexport default class AnimatedPoints {\r\n\r\n    constructor(numberOfPoints) {\r\n        this.animationTime = 0;\r\n        this.animationPos = 0;\r\n\r\n        this.easingFunction = (v) => {\r\n            return v\r\n        };\r\n\r\n        this.numberOfPoints = numberOfPoints;\r\n        this.fromProperties = {\r\n            r: new Float32Array(this.numberOfPoints),\r\n            g: new Float32Array(this.numberOfPoints),\r\n            b: new Float32Array(this.numberOfPoints),\r\n            size: new Float32Array(this.numberOfPoints),\r\n        };\r\n        this.toProperties = {\r\n            r: new Float32Array(this.numberOfPoints),\r\n            g: new Float32Array(this.numberOfPoints),\r\n            b: new Float32Array(this.numberOfPoints),\r\n            size: new Float32Array(this.numberOfPoints),\r\n        };\r\n\r\n        this.fromPositions = new Float32Array(this.numberOfPoints * 3);\r\n        this.toPositions = new Float32Array(this.numberOfPoints * 3);\r\n\r\n        this.geometry = new THREE.BufferGeometry();\r\n        this.material = this.getMaterial();\r\n\r\n        for (let i = 0; i < this.numberOfPoints; i++) {\r\n            Object.keys(this.fromProperties).forEach((k) => {\r\n                this.fromProperties[k][i] = 0.1;\r\n                this.toProperties[k][i] = 0.1;\r\n            });\r\n        }\r\n\r\n\r\n        this.particles = new THREE.Points(this.geometry, this.material);\r\n    }\r\n\r\n    getMaterial() {\r\n        //another approach to using shader glsl files and importing them into js https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderChunk.js\r\n        var vertexShader = () => {\r\n            return `\r\n        attribute float size_from;\r\n        attribute float size_to;\r\n        \r\n        attribute float r_from;\r\n        attribute float g_from;\r\n        attribute float b_from; \r\n        \r\n        attribute float r_to;\r\n        attribute float g_to;\r\n        attribute float b_to;\r\n         \r\n        attribute vec3 position_to;\r\n\r\n        varying vec3 vColor;\r\n        uniform float animationPos;\r\n        \r\n        void main() {\r\n            vColor = vec3(\r\n                r_from * (1.0 - animationPos) + r_to * animationPos,\r\n                g_from * (1.0 - animationPos) + g_to * animationPos,\r\n                b_from * (1.0 - animationPos) + b_to * animationPos            \r\n            );\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position * (1.0 - animationPos) + position_to * animationPos, 1.0);\r\n            gl_PointSize = size_from * (1.0 - animationPos) + size_to * animationPos;\r\n        }\r\n        `\r\n        };\r\n        var fragmentShader = () => {\r\n            return `\r\n            varying vec3 vColor;\r\n\t\t\t\r\n\t\t\tvoid main() {\r\n\t\t\t\tgl_FragColor = vec4( vColor, 1.0 );\r\n\t\t\t}\r\n        `\r\n        };\r\n\r\n        //\"position\" is used internally by ThreeJS so the name cannot change\r\n        this.geometry.addAttribute('position', new THREE.BufferAttribute(this.fromPositions, 3));\r\n        this.geometry.addAttribute('position_to', new THREE.BufferAttribute(this.toPositions, 3));\r\n\r\n        Object.keys(this.fromProperties).forEach((k) => {\r\n            this.geometry.addAttribute(k+'_from', new THREE.BufferAttribute(this.fromProperties[k], 1));\r\n            this.geometry.addAttribute(k+'_to', new THREE.BufferAttribute(this.toProperties[k], 1));\r\n        });\r\n\r\n        return new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                animationPos: {value: this.animationPos}\r\n            },\r\n            vertexShader: vertexShader(),\r\n            fragmentShader: fragmentShader()\r\n\r\n        });\r\n    }\r\n\r\n    /**\r\n     * set the properties to which to animate using an optional easing function\r\n     * @param {Object[]} properties - an array of objects\r\n     *      @param {Number} [properties[].x] - x position\r\n     *      @param {Number} [properties[].y] - y position\r\n     *      @param {Number} [properties[].z] - z position\r\n     *      @param {Number} [properties[].size] - size in pixels\r\n     *      @param {string} [properties[].color] - color in hex format (#ff0000)\r\n     * @param {Function} [easingFn] - an easing function such as those found in the 'eases' package https://www.npmjs.com/package/eases\r\n     */\r\n    setProperties(properties, easingFn) {\r\n        var propKeys = Object.keys(this.fromProperties);\r\n\r\n        if (easingFn) {\r\n            this.easingFunction = easingFn;\r\n        }\r\n\r\n        var keysWithChanges = {};\r\n\r\n        var keyMatch = {\r\n            'position': ['position', 'position_to'],//special case since 'position' is hard-coded in ThreeJSs\r\n        };\r\n\r\n        propKeys.forEach((k) => {\r\n            keyMatch[k] = [`${k}_from`, `${k}_to`]\r\n        });\r\n\r\n        //when setProperties is called, we switch the from position to be the current position of the nodes (even if in the middle of an animation)\r\n        //these values are calculated internally in the shader, but we don't have access to them there\r\n        properties.forEach((obj, i) => {\r\n            propKeys.forEach((k) => {\r\n                this.fromProperties[k][i] = this.fromProperties[k][i] * (1 - this.animationPos) + this.toProperties[k][i] * this.animationPos;\r\n            });\r\n            this.fromPositions[i * 3] = this.fromPositions[i * 3] * (1 - this.animationPos) + this.toPositions[i * 3] * this.animationPos;\r\n            this.fromPositions[i * 3 + 1] = this.fromPositions[i * 3 + 1] * (1 - this.animationPos) + this.toPositions[i * 3 + 1] * this.animationPos;\r\n        });\r\n\r\n        properties.forEach((obj, i) => {\r\n            if (obj.color) {\r\n                AnimatedPoints._injectRGB(obj, obj.color)\r\n            }\r\n            propKeys.forEach((k) => {\r\n                if (obj[k] !== null) {\r\n                    if (this.toProperties[k][i] !== obj[k]) {\r\n                        this.toProperties[k][i] = obj[k];\r\n                        keysWithChanges[k] = true;\r\n                    }\r\n                }\r\n            });\r\n            if (obj.x !== null) {\r\n                if (this.toPositions[i * 3] !== obj.x) {\r\n                    this.toPositions[i * 3] = obj.x;\r\n                    keysWithChanges['position'] = true;\r\n                }\r\n            }\r\n            if (obj.y !== null) {\r\n                if (this.toPositions[i * 3 + 1] !== obj.y) {\r\n                    this.toPositions[i * 3 + 1] = obj.y;\r\n                    keysWithChanges['position'] = true;\r\n                }\r\n            }\r\n            if (obj.z !== null) {\r\n                if (this.toPositions[i * 3 + 2] !== obj.z) {\r\n                    this.toPositions[i * 3 + 2] = obj.z;\r\n                    keysWithChanges['position'] = true;\r\n                }\r\n            }\r\n        });\r\n\r\n        Object.keys(keysWithChanges).forEach((key) => {\r\n            keyMatch[key].forEach((attr, i) => {\r\n                console.log(`Needs update ${attr}`);\r\n                this.geometry.attributes[attr].needsUpdate = true;\r\n            });\r\n        });\r\n\r\n        //TODO if we set the same targets twice it won't call needsUpdate, but it will reset the animation\r\n        this.setAnimationTime(0);\r\n\r\n    }\r\n\r\n    setAnimationTime(val) {\r\n        this.animationTime = Math.max(0, Math.min(1, val));\r\n        this.animationPos = this.easingFunction(this.animationTime);\r\n\r\n        this.material.uniforms.animationPos.value = this.animationPos;\r\n    }\r\n\r\n    step(amt) {\r\n        this.setAnimationTime(this.animationTime + amt);\r\n    }\r\n\r\n    getObject() {\r\n        return this.particles;\r\n    }\r\n\r\n    static _hexToRgb(hex) {\r\n        var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n        return result ? {\r\n            r: parseInt(result[1], 16),\r\n            g: parseInt(result[2], 16),\r\n            b: parseInt(result[3], 16)\r\n        } : null;\r\n    }\r\n\r\n    static _injectRGB(obj, color) {\r\n        var rgb = AnimatedPoints._hexToRgb(color);\r\n        if (!rgb) {\r\n            obj.r = 0;\r\n            obj.g = 0;\r\n            obj.b = 0;\r\n            return;\r\n        }\r\n        obj.r = rgb.r / 255;\r\n        obj.g = rgb.g / 255;\r\n        obj.b = rgb.b / 255;\r\n\r\n    }\r\n}"],"names":["AnimatedPoints","numberOfPoints","animationTime","animationPos","easingFunction","v","fromProperties","Float32Array","toProperties","fromPositions","toPositions","geometry","THREE","BufferGeometry","material","getMaterial","i","keys","forEach","k","particles","Points","vertexShader","fragmentShader","addAttribute","BufferAttribute","ShaderMaterial","value","properties","easingFn","propKeys","Object","keysWithChanges","keyMatch","obj","color","_injectRGB","x","y","z","key","attr","log","attributes","needsUpdate","setAnimationTime","val","Math","max","min","uniforms","amt","hex","result","exec","parseInt","rgb","_hexToRgb","r","g","b"],"mappings":"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"}